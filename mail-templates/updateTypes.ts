import path from 'path';
import { readdirSync, writeFileSync, readFileSync } from 'fs';

const __dirname = path.dirname(new URL(import.meta.url).pathname);

const mailLibPath = path.join(__dirname, '..', 'src', 'lib', 'server', 'mail.ts');

const templates = readdirSync(path.join(__dirname));

const templateNamesAndDataKeys: Record<string, string[]> = Object.fromEntries(
	templates
		.filter((f) => f.endsWith('.mjml') && !f.startsWith('_'))
		.map((f) => [
			f.replace(/\.mjml$/, ''),
			[
				...readFileSync(path.join(__dirname, f))
					.toString()
					.matchAll(/\{\{\s*(?:#each\s*)?(\w+)(\.\w+)*\s*\}\}/g)
			].map((match) => match[1])
		])
);

console.info(
	'Templates: \n' +
		Object.keys(templateNamesAndDataKeys)
			.map((t) => `- ${t}`)
			.join('\n')
);

let insideGeneratedContent = false;
let newTypesInserted = false;
const layoutDataKeys = ['contactEmail', 'recipient'];
const declaration = `/**
 * @generated by running pnpm update-mail-templates
 * Valid email templates
 */
export type EmailTemplateNameAndData = ${Object.entries(templateNamesAndDataKeys)
	.map(
		([templateName, dataKeys]) =>
			`{ template: '${templateName}'; data: { ${[
				...new Set(dataKeys.filter((k) => !layoutDataKeys.includes(k)))
			]
				.map((k) => `${k}: any`)
				.join('; ')} }}`
	)
	.join(' | ')};`;
writeFileSync(
	mailLibPath,
	readFileSync(mailLibPath, 'utf-8')
		.split('\n')
		.map((l) => {
			if (/\/\/\s*generate:EmailTemplates/.test(l)) {
				insideGeneratedContent = true;
			} else if (insideGeneratedContent) {
				if (/\/\/\s*end generate/.test(l)) {
					insideGeneratedContent = false;
				} else {
					if (newTypesInserted) {
						return '';
					}
					newTypesInserted = true;
					return declaration;
				}
			}
			return l;
		})
		.join('\n')
);
